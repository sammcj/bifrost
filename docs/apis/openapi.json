{
  "openapi": "3.0.3",
  "info": {
    "title": "Bifrost Gateway",
    "version": "1.3",
    "description": "The Bifrost API provides a unified interface to various AI models and services.",
    "contact": {
      "name": "Contact Us",
      "url": "https://getmaxim.ai/bifrost"
    },
    "license": {
      "name": "Apache 2.0",
      "url": "https://opensource.org/licenses/Apache-2.0"
    }
  },
  "servers": [
    {
      "url": "http://localhost:8080",
      "description": "Local development server"
    }
  ],
  "paths": {
    "/v1/chat/completions": {
      "post": {
        "summary": "Create Chat Completion",
        "description": "Creates a model response for the given chat conversation.",
        "operationId": "createChatCompletion",
        "tags": [
          "Bifrost Core",
          "Chat Completions"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/v1/completions": {
      "post": {
        "summary": "Create Text Completion",
        "description": "Creates a completion for the provided prompt and parameters.",
        "operationId": "createTextCompletion",
        "tags": [
          "Bifrost Core",
          "Text Completions"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/v1/embeddings": {
      "post": {
        "summary": "Create Embeddings",
        "description": "Creates an embedding vector representing the input text.",
        "operationId": "createEmbeddings",
        "tags": [
          "Bifrost Core",
          "Embeddings"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostEmbedding"
                }
              }
            }
          }
        }
      }
    },
    "/v1/responses": {
      "post": {
        "summary": "Create Response",
        "description": "Creates a response using the Responses API format.",
        "operationId": "createResponse",
        "tags": [
          "Bifrost Core",
          "Responses"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResponsesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/v1/audio/speech": {
      "post": {
        "summary": "Create Speech",
        "description": "Generates audio from the input text.",
        "operationId": "createSpeech",
        "tags": [
          "Bifrost Core",
          "Audio"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpeechRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Audio file",
            "content": {
              "audio/mpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "audio/wav": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/v1/audio/transcriptions": {
      "post": {
        "summary": "Create Transcription",
        "description": "Transcribes audio into the input language.",
        "operationId": "createTranscription",
        "tags": [
          "Bifrost Core",
          "Audio"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/TranscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostTranscribe"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/health": {
      "get": {
        "summary": "Get Health",
        "description": "Returns the health of the server. This endpoint can be safely used as liveness probe and readiness probe for Kubernetes. It also internally validates connection to config store, log store, vector store",
        "operationId": "getHealth",
        "tags": [
          "Health"
        ],
        "responses": {
          "200": {
            "description": "Server is healthy and all stores are available",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "example": "ok"
                    }
                  }
                }
              }
            }
          },
          "503": {
            "description": "Service unavailable. One or more required stores (config store, log store, or vector store) are not available."
          }
        }
      }      
    },
    "/metrics": {
      "get": {
        "summary": "Get Prometheus Metrics",
        "description": "Returns Prometheus-compatible metrics for monitoring request counts, latency, token usage, and error rates.",
        "operationId": "getMetrics",
        "tags": [
          "Monitoring"
        ],
        "responses": {
          "200": {
            "description": "Prometheus metrics in text format",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                },
                "example": "# HELP http_requests_total Total number of HTTP requests\n# TYPE http_requests_total counter\nhttp_requests_total{method=\"POST\",handler=\"/v1/chat/completions\",code=\"200\"} 42\n"
              }
            }
          }
        }
      }
    },
    "/api/version": {
      "get": {
        "summary": "Get API Version",
        "description": "Retrieves the current version of the Bifrost API.",
        "operationId": "getVersion",
        "tags": [
          "General"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/api/keys": {
      "get": {
        "summary": "List All Keys",
        "description": "Retrieves a list of all API keys configured across all providers.",
        "operationId": "listKeys",
        "tags": [
          "Providers"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Key"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/providers": {
      "get": {
        "summary": "List all providers",
        "operationId": "listProviders",
        "tags": [
          "Providers"
        ],
        "responses": {
          "200": {
            "description": "A list of all configured providers.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListProvidersResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Add a new provider",
        "operationId": "addProvider",
        "tags": [
          "Providers"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddProviderRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The newly added provider's configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request body or parameters."
          },
          "409": {
            "description": "Provider already exists."
          }
        }
      }
    },
    "/api/providers/{provider}": {
      "get": {
        "summary": "Get a specific provider",
        "operationId": "getProvider",
        "tags": [
          "Providers"
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "path",
            "required": true,
            "description": "The name of the provider",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The requested provider's configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderResponse"
                }
              }
            }
          },
          "404": {
            "description": "Provider not found."
          }
        }
      },
      "put": {
        "summary": "Update a provider's configuration",
        "description": "This endpoint upserts the provider configuration. All fields must be provided in the request body, as partial updates are not supported.",
        "operationId": "updateProvider",
        "tags": [
          "Providers"
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "path",
            "required": true,
            "description": "The name of the provider to update",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateProviderRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The updated provider's configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request body or parameters."
          },
          "404": {
            "description": "Provider not found."
          }
        }
      },
      "delete": {
        "summary": "Remove a provider",
        "operationId": "deleteProvider",
        "tags": [
          "Providers"
        ],
        "parameters": [
          {
            "name": "provider",
            "in": "path",
            "required": true,
            "description": "The name of the provider to delete",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Confirmation of provider deletion.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProviderResponse"
                }
              }
            }
          },
          "404": {
            "description": "Provider not found."
          }
        }
      }
    },
    "/api/plugins": {
      "get": {
        "summary": "Get All Plugins",
        "description": "Retrieves a list of all configured plugins.",
        "operationId": "getPlugins",
        "tags": [
          "Plugins"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "plugins": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Plugin"
                      }
                    },
                    "count": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create Plugin",
        "description": "Creates a new plugin configuration.",
        "operationId": "createPlugin",
        "tags": [
          "Plugins"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreatePluginRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Plugin created successfully"
          }
        }
      }
    },
    "/api/plugins/{name}": {
      "get": {
        "summary": "Get Plugin",
        "description": "Retrieves a specific plugin configuration by name.",
        "operationId": "getPlugin",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Plugin"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update Plugin",
        "description": "Updates an existing plugin configuration.",
        "operationId": "updatePlugin",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdatePluginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Plugin updated successfully"
          }
        }
      },
      "delete": {
        "summary": "Delete Plugin",
        "description": "Deletes a plugin configuration.",
        "operationId": "deletePlugin",
        "tags": [
          "Plugins"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Plugin deleted successfully"
          }
        }
      }
    },
    "/api/governance/virtual-keys": {
      "get": {
        "summary": "Get All Virtual Keys",
        "description": "Retrieves a list of all virtual keys.",
        "operationId": "getVirtualKeys",
        "tags": [
          "Governance"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "virtual_keys": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/VirtualKey"
                      }
                    },
                    "count": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create Virtual Key",
        "description": "Creates a new virtual key.",
        "operationId": "createVirtualKey",
        "tags": [
          "Governance"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateVirtualKeyRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Virtual key created successfully"
          }
        }
      }
    },
    "/api/governance/virtual-keys/{vk_id}": {
      "get": {
        "summary": "Get Virtual Key",
        "description": "Retrieves a specific virtual key by ID.",
        "operationId": "getVirtualKey",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "vk_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VirtualKey"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update Virtual Key",
        "description": "Updates an existing virtual key.",
        "operationId": "updateVirtualKey",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "vk_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateVirtualKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Virtual key updated successfully"
          }
        }
      },
      "delete": {
        "summary": "Delete Virtual Key",
        "description": "Deletes a virtual key.",
        "operationId": "deleteVirtualKey",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "vk_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Virtual key deleted successfully"
          }
        }
      }
    },
    "/api/governance/teams": {
      "get": {
        "summary": "Get All Teams",
        "description": "Retrieves a list of all teams.",
        "operationId": "getTeams",
        "tags": [
          "Governance"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "teams": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Team"
                      }
                    },
                    "count": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create Team",
        "description": "Creates a new team.",
        "operationId": "createTeam",
        "tags": [
          "Governance"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTeamRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Team created successfully"
          }
        }
      }
    },
    "/api/governance/teams/{team_id}": {
      "get": {
        "summary": "Get Team",
        "description": "Retrieves a specific team by ID.",
        "operationId": "getTeam",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Team"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update Team",
        "description": "Updates an existing team.",
        "operationId": "updateTeam",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTeamRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Team updated successfully"
          }
        }
      },
      "delete": {
        "summary": "Delete Team",
        "description": "Deletes a team.",
        "operationId": "deleteTeam",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Team deleted successfully"
          }
        }
      }
    },
    "/api/governance/customers": {
      "get": {
        "summary": "Get All Customers",
        "description": "Retrieves a list of all customers.",
        "operationId": "getCustomers",
        "tags": [
          "Governance"
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "customers": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Customer"
                      }
                    },
                    "count": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create Customer",
        "description": "Creates a new customer.",
        "operationId": "createCustomer",
        "tags": [
          "Governance"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCustomerRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Customer created successfully"
          }
        }
      }
    },
    "/api/governance/customers/{customer_id}": {
      "get": {
        "summary": "Get Customer",
        "description": "Retrieves a specific customer by ID.",
        "operationId": "getCustomer",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "customer_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Customer"
                }
              }
            }
          }
        }
      },
      "put": {
        "summary": "Update Customer",
        "description": "Updates an existing customer.",
        "operationId": "updateCustomer",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "customer_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateCustomerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Customer updated successfully"
          }
        }
      },
      "delete": {
        "summary": "Delete Customer",
        "description": "Deletes a customer.",
        "operationId": "deleteCustomer",
        "tags": [
          "Governance"
        ],
        "parameters": [
          {
            "name": "customer_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Customer deleted successfully"
          }
        }
      }
    },
    "/ws": {
      "get": {
        "summary": "WebSocket for Log Streaming",
        "description": "Establishes a WebSocket connection for real-time log streaming.",
        "operationId": "webSocketLogStream",
        "tags": [
          "Logging"
        ],
        "responses": {
          "101": {
            "description": "Switching Protocols - WebSocket connection established"
          }
        }
      }
    },
    "/api/logs": {
      "get": {
        "summary": "Search and filter logs",
        "operationId": "searchLogs",
        "tags": [
          "Logging"
        ],
        "parameters": [
          {
            "name": "providers",
            "in": "query",
            "description": "Comma-separated list of providers to filter by",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "models",
            "in": "query",
            "description": "Comma-separated list of models to filter by",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Comma-separated list of statuses to filter by",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objects",
            "in": "query",
            "description": "Comma-separated list of objects to filter by",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "start_time",
            "in": "query",
            "description": "Start time for the time range filter (RFC3339 format)",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "end_time",
            "in": "query",
            "description": "End time for the time range filter (RFC3339 format)",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "min_latency",
            "in": "query",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "max_latency",
            "in": "query",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "min_tokens",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "max_tokens",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "min_cost",
            "in": "query",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "max_cost",
            "in": "query",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "content_search",
            "in": "query",
            "description": "Full-text search in request/response bodies",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of logs to return",
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 1000
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of logs to skip",
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "sort_by",
            "in": "query",
            "description": "Field to sort by",
            "schema": {
              "type": "string",
              "enum": [
                "timestamp",
                "latency",
                "tokens",
                "cost"
              ],
              "default": "timestamp"
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Sort order",
            "schema": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ],
              "default": "desc"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A paginated list of logs matching the criteria.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogSearchResult"
                }
              }
            }
          }
        }
      }
    },
    "/api/logs/dropped": {
      "get": {
        "summary": "Get the number of dropped requests",
        "operationId": "getDroppedRequests",
        "tags": [
          "Logging"
        ],
        "responses": {
          "200": {
            "description": "The total count of dropped requests.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "dropped_requests": {
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/completions": {
      "post": {
        "summary": "OpenAI Compatible Text Completions",
        "description": "OpenAI-compatible text completions endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiTextCompletions",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/completions": {
      "post": {
        "summary": "OpenAI Compatible Text Completions (alternative path)",
        "description": "OpenAI-compatible text completions endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiTextCompletionsAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/completions": {
      "post": {
        "summary": "Azure OpenAI Compatible Text Completions",
        "description": "Azure OpenAI-compatible text completions endpoint for specific deployments.",
        "operationId": "azureTextCompletions",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Azure OpenAI-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/chat/completions": {
      "post": {
        "summary": "OpenAI Compatible Chat Completions",
        "description": "OpenAI-compatible chat completions endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiChatCompletions",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/chat/completions": {
      "post": {
        "summary": "OpenAI Compatible Chat Completions (alternative path)",
        "description": "OpenAI-compatible chat completions endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiChatCompletionsAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/chat/completions": {
      "post": {
        "summary": "Azure OpenAI Compatible Chat Completions",
        "description": "Azure OpenAI-compatible chat completions endpoint for specific deployments.",
        "operationId": "azureChatCompletions",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Azure OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/responses": {
      "post": {
        "summary": "OpenAI Compatible Responses",
        "description": "OpenAI-compatible responses endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiResponses",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResponsesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible responses response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/responses": {
      "post": {
        "summary": "OpenAI Compatible Responses (alternative path)",
        "description": "OpenAI-compatible responses endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiResponsesAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResponsesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible responses response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/responses": {
      "post": {
        "summary": "Azure OpenAI Compatible Responses",
        "description": "Azure OpenAI-compatible responses endpoint for specific deployments.",
        "operationId": "azureResponses",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResponsesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Azure OpenAI-compatible responses response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/embeddings": {
      "post": {
        "summary": "OpenAI Compatible Embeddings",
        "description": "OpenAI-compatible embeddings endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiEmbeddings",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible embeddings response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostEmbedding"
                }
              }
            }
          }
        }
      }
    },
    "/openai/embeddings": {
      "post": {
        "summary": "OpenAI Compatible Embeddings (alternative path)",
        "description": "OpenAI-compatible embeddings endpoint that converts requests to Bifrost format and returns OpenAI-compatible responses.",
        "operationId": "openaiEmbeddingsAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible embeddings response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostEmbedding"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/embeddings": {
      "post": {
        "summary": "Azure OpenAI Compatible Embeddings",
        "description": "Azure OpenAI-compatible embeddings endpoint for specific deployments.",
        "operationId": "azureEmbeddings",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmbeddingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Azure OpenAI-compatible embeddings response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostEmbedding"
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/audio/speech": {
      "post": {
        "summary": "OpenAI Compatible Speech Synthesis",
        "description": "OpenAI-compatible speech synthesis endpoint.",
        "operationId": "openaiSpeech",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpeechRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Audio file",
            "content": {
              "audio/mpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          }
        }
      }
    },
    "/openai/audio/speech": {
      "post": {
        "summary": "OpenAI Compatible Speech Synthesis (alternative path)",
        "description": "OpenAI-compatible speech synthesis endpoint.",
        "operationId": "openaiSpeechAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpeechRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Audio file",
            "content": {
              "audio/mpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/audio/speech": {
      "post": {
        "summary": "Azure OpenAI Compatible Speech Synthesis",
        "description": "Azure OpenAI-compatible speech synthesis endpoint for specific deployments.",
        "operationId": "azureSpeech",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpeechRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Audio file",
            "content": {
              "audio/mpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          }
        }
      }
    },
    "/openai/v1/audio/transcriptions": {
      "post": {
        "summary": "OpenAI Compatible Audio Transcription",
        "description": "OpenAI-compatible audio transcription endpoint.",
        "operationId": "openaiTranscription",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/TranscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transcription result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostTranscribe"
                }
              }
            }
          }
        }
      }
    },
    "/openai/audio/transcriptions": {
      "post": {
        "summary": "OpenAI Compatible Audio Transcription (alternative path)",
        "description": "OpenAI-compatible audio transcription endpoint.",
        "operationId": "openaiTranscriptionAlt",
        "tags": [
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/TranscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transcription result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostTranscribe"
                }
              }
            }
          }
        }
      }
    },
    "/openai/deployments/{deployment-id}/audio/transcriptions": {
      "post": {
        "summary": "Azure OpenAI Compatible Audio Transcription",
        "description": "Azure OpenAI-compatible audio transcription endpoint for specific deployments.",
        "operationId": "azureTranscription",
        "tags": [
          "Integration - OpenAI"
        ],
        "parameters": [
          {
            "name": "deployment-id",
            "in": "path",
            "required": true,
            "description": "Azure deployment ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/TranscriptionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transcription result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostTranscribe"
                }
              }
            }
          }
        }
      }
    },
    "/anthropic/v1/complete": {
      "post": {
        "summary": "Anthropic Compatible Text Completions",
        "description": "Anthropic-compatible text completions endpoint.",
        "operationId": "anthropicTextCompletions",
        "tags": [
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/anthropic/v1/messages": {
      "post": {
        "summary": "Anthropic Compatible Messages",
        "description": "Anthropic-compatible messages endpoint.",
        "operationId": "anthropicMessages",
        "tags": [
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible message response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/genai/v1beta/models/{model}:generateContent": {
      "post": {
        "summary": "Google Gemini Compatible Completions",
        "description": "Google Gemini-compatible completions endpoint.",
        "operationId": "geminiCompletions",
        "tags": [
          "Integration - Gemini"
        ],
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "description": "Model name",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Gemini-compatible completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/langchain/v1/chat/completions": {
      "post": {
        "summary": "LangChain/OpenAI Compatible Chat Completions",
        "description": "LangChain compatible endpoint for OpenAI-style chat completions.",
        "operationId": "langchainOpenAIChatCompletions",
        "tags": [
          "Integration - LangChain",
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/langchain/v1/complete": {
      "post": {
        "summary": "LangChain/Anthropic Compatible Text Completions",
        "description": "LangChain compatible endpoint for Anthropic-style text completions.",
        "operationId": "langchainAnthropicTextCompletions",
        "tags": [
          "Integration - LangChain",
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/langchain/v1/messages": {
      "post": {
        "summary": "LangChain/Anthropic Compatible Messages",
        "description": "LangChain compatible endpoint for Anthropic-style messages.",
        "operationId": "langchainAnthropicMessages",
        "tags": [
          "Integration - LangChain",
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible message response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/langchain/v1beta/models/{model}:generateContent": {
      "post": {
        "summary": "LangChain/Gemini Compatible Completions",
        "description": "LangChain compatible endpoint for Google Gemini-style completions.",
        "operationId": "langchainGeminiCompletions",
        "tags": [
          "Integration - LangChain",
          "Integration - Gemini"
        ],
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "description": "Model name",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Gemini-compatible completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/litellm/v1/chat/completions": {
      "post": {
        "summary": "LiteLLM/OpenAI Compatible Chat Completions",
        "description": "LiteLLM compatible endpoint for OpenAI-style chat completions.",
        "operationId": "litellmOpenAIChatCompletions",
        "tags": [
          "Integration - LiteLLM",
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/litellm/chat/completions": {
      "post": {
        "summary": "LiteLLM/OpenAI Compatible Chat Completions (alternative path)",
        "description": "LiteLLM compatible endpoint for OpenAI-style chat completions.",
        "operationId": "litellmOpenAIChatCompletionsAlt",
        "tags": [
          "Integration - LiteLLM",
          "Integration - OpenAI"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI-compatible chat completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/litellm/v1/complete": {
      "post": {
        "summary": "LiteLLM/Anthropic Compatible Text Completions",
        "description": "LiteLLM compatible endpoint for Anthropic-style text completions.",
        "operationId": "litellmAnthropicTextCompletions",
        "tags": [
          "Integration - LiteLLM",
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TextCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible text completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/litellm/v1/messages": {
      "post": {
        "summary": "LiteLLM/Anthropic Compatible Messages",
        "description": "LiteLLM compatible endpoint for Anthropic-style messages.",
        "operationId": "litellmAnthropicMessages",
        "tags": [
          "Integration - LiteLLM",
          "Integration - Anthropic"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Anthropic-compatible message response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    },
    "/litellm/v1beta/models/{model}:generateContent": {
      "post": {
        "summary": "LiteLLM/Gemini Compatible Completions",
        "description": "LiteLLM compatible endpoint for Google Gemini-style completions.",
        "operationId": "litellmGeminiCompletions",
        "tags": [
          "Integration - LiteLLM",
          "Integration - Gemini"
        ],
        "parameters": [
          {
            "name": "model",
            "in": "path",
            "required": true,
            "description": "Model name",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Gemini-compatible completion response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostResponse"
                }
              },
              "text/event-stream": {
                "schema": {
                  "$ref": "#/components/schemas/BifrostStream"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "ChatCompletionRequest": {
        "type": "object",
        "required": [
          "model",
          "messages"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model identifier in 'provider/model' format (e.g., 'openai/gpt-4o-mini', 'anthropic/claude-3-sonnet-20240229')",
            "example": "openai/gpt-4o-mini"
          },
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            },
            "description": "Array of chat messages",
            "minItems": 1
          },
          "max_tokens": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum number of tokens to generate. Note: this is an alias for `max_completion_tokens` and will be overridden by it if both are present.",
            "example": 1000
          },
          "temperature": {
            "type": "number",
            "minimum": 0,
            "maximum": 2,
            "description": "Controls randomness in the output. Higher values make the output more random, while lower values make it more deterministic."
          },
          "top_p": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Controls diversity via nucleus sampling. 0.5 means half of all likelihood-weighted options are considered."
          },
          "n": {
            "type": "integer",
            "description": "Number of chat completion choices to generate for each input message.",
            "default": 1
          },
          "stream": {
            "type": "boolean",
            "description": "If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only server-sent events as they become available.",
            "default": false
          },
          "stream_options": {
            "$ref": "#/components/schemas/ChatStreamOptions"
          },
          "stop": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "description": "Up to 4 sequences where the API will stop generating further tokens."
          },
          "presence_penalty": {
            "type": "number",
            "minimum": -2,
            "maximum": 2,
            "description": "Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics."
          },
          "frequency_penalty": {
            "type": "number",
            "minimum": -2,
            "maximum": 2,
            "description": "Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim."
          },
          "logit_bias": {
            "type": "object",
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Modify the likelihood of specified tokens appearing in the completion. Accepts a JSON object that maps tokens to an associated bias value from -100 to 100."
          },
          "logprobs": {
            "type": "boolean",
            "description": "Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`.",
            "default": false
          },
          "top_logprobs": {
            "type": "integer",
            "minimum": 0,
            "maximum": 20,
            "description": "An integer between 0 and 20. The number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used."
          },
          "max_completion_tokens": {
            "type": "integer",
            "description": "The maximum number of tokens that can be generated in the chat completion."
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true,
            "description": "A set of key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format."
          },
          "modalities": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of modalities to use for the response."
          },
          "parallel_tool_calls": {
            "type": "boolean",
            "description": "Whether to enable parallel tool calls. If set to `true`, the model will be able to call multiple tools in a single response."
          },
          "prompt_cache_key": {
            "type": "string",
            "description": "A key to use for caching the prompt."
          },
          "reasoning_effort": {
            "type": "string",
            "description": "The reasoning effort to use for the response."
          },
          "response_format": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "text",
                  "json_object"
                ],
                "description": "The format of the response. Can be `text` or `json_object`."
              }
            }
          },
          "safety_identifier": {
            "type": "string",
            "description": "A unique identifier for the safety settings to use for the response."
          },
          "seed": {
            "type": "integer",
            "description": "This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result. Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend."
          },
          "service_tier": {
            "type": "string",
            "enum": [
              "auto",
              "default"
            ],
            "description": "The service tier to use for the response. Can be `auto` or `default`."
          },
          "store": {
            "type": "boolean",
            "description": "Whether to store the request and response in the log store."
          },
          "tool_choice": {
            "$ref": "#/components/schemas/ChatToolChoice"
          },
          "tools": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChatTool"
            }
          },
          "user": {
            "type": "string",
            "description": "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse."
          },
          "verbosity": {
            "type": "string",
            "description": "The verbosity level of the response."
          },
          "fallbacks": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Fallback model names in 'provider/model' format",
            "example": [
              "anthropic/claude-3-sonnet-20240229",
              "openai/gpt-4o"
            ]
          }
        }
      },
      "ChatStreamOptions": {
        "type": "object",
        "properties": {
          "include_usage": {
            "type": "boolean",
            "description": "If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage stats for the completion, and the `model` field identify the model used."
          }
        }
      },
      "ChatTool": {
        "type": "object",
        "required": [
          "type",
          "function"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "The type of the tool. Currently, only `function` is supported."
          },
          "function": {
            "type": "object",
            "required": [
              "name"
            ],
            "properties": {
              "description": {
                "type": "string",
                "description": "A description of what the function does."
              },
              "name": {
                "type": "string",
                "description": "The name of the function to be called."
              },
              "parameters": {
                "type": "object",
                "description": "The parameters the functions accepts, described as a JSON Schema object."
              }
            }
          }
        }
      },
      "ChatToolChoice": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "none",
              "auto",
              "required"
            ]
          },
          {
            "$ref": "#/components/schemas/ChatTool"
          }
        ],
        "description": "Controls which (if any) function is called by the model. `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function. `required` means the model must call a function. Specifying a particular function via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that function."
      },
      "TextCompletionRequest": {
        "type": "object",
        "required": [
          "model",
          "text"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model identifier in 'provider/model' format (e.g., 'anthropic/claude-2.1')",
            "example": "anthropic/claude-2.1"
          },
          "prompt": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "description": "Text prompt for completion",
            "example": "The benefits of artificial intelligence include"
          },
          "stream": {
            "type": "boolean",
            "description": "If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only server-sent events as they become available.",
            "default": false
          },
          "best_of": {
            "type": "integer",
            "description": "Generates `best_of` completions server-side and returns the 'best' one. See `n` for comparison."
          },
          "echo": {
            "type": "boolean",
            "description": "Echo back the prompt in addition to the completion.",
            "default": false
          },
          "frequency_penalty": {
            "type": "number",
            "minimum": -2,
            "maximum": 2,
            "description": "Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim."
          },
          "logit_bias": {
            "type": "object",
            "additionalProperties": {
              "type": "integer"
            },
            "description": "Modify the likelihood of specified tokens appearing in the completion. Accepts a JSON object that maps tokens to an associated bias value from -100 to 100."
          },
          "logprobs": {
            "type": "integer",
            "description": "Include the log probabilities on the `logprobs` most likely tokens, as well the chosen tokens."
          },
          "max_tokens": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum number of tokens to generate",
            "example": 1000
          },
          "n": {
            "type": "integer",
            "description": "How many completions to generate for each prompt.",
            "default": 1
          },
          "presence_penalty": {
            "type": "number",
            "minimum": -2,
            "maximum": 2,
            "description": "Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics."
          },
          "seed": {
            "type": "integer",
            "description": "This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result. Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend."
          },
          "stop": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "description": "Up to 4 sequences where the API will stop generating further tokens."
          },
          "stream_options": {
            "$ref": "#/components/schemas/ChatStreamOptions"
          },
          "suffix": {
            "type": "string",
            "description": "The suffix that comes after a completion of inserted text."
          },
          "temperature": {
            "type": "number",
            "minimum": 0,
            "maximum": 2,
            "description": "Controls randomness in the output. Higher values make the output more random, while lower values make it more deterministic."
          },
          "top_p": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Controls diversity via nucleus sampling. 0.5 means half of all likelihood-weighted options are considered."
          },
          "user": {
            "type": "string",
            "description": "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse."
          },
          "fallbacks": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Fallback model names in 'provider/model' format",
            "example": [
              "anthropic/claude-3-sonnet-20240229",
              "openai/gpt-4o"
            ]
          }
        }
      },
      "ModelProvider": {
        "type": "string",
        "enum": [
          "openai",
          "anthropic",
          "azure",
          "bedrock",
          "cohere",
          "vertex",
          "mistral",
          "ollama",
          "gemini",
          "groq",
          "openrouter",
          "sgl",
          "parasail",
          "cerebras"
        ],
        "description": "AI model provider",
        "example": "openai"
      },
      "RequestType": {
        "type": "string",
        "enum": [
          "text_completion",
          "chat_completion",
          "chat_completion_stream",
          "responses",
          "responses_stream",
          "embedding",
          "speech",
          "speech_stream",
          "transcription",
          "transcription_stream"
        ],
        "description": "Request type"
      },
      "ChatMessage": {
        "type": "object",
        "required": [
          "role"
        ],
        "properties": {
          "role": {
            "$ref": "#/components/schemas/MessageRole"
          },
          "content": {
            "oneOf": [
              {
                "type": "string",
                "description": "Simple text content",
                "example": "Hello, how are you?"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ContentBlock"
                },
                "description": "Structured content with text and images"
              }
            ],
            "description": "Message content - can be simple text or structured content with text and images"
          },
          "tool_call_id": {
            "type": "string",
            "description": "ID of the tool call (for tool messages)"
          },
          "tool_calls": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolCall"
            },
            "description": "Tool calls made by assistant"
          },
          "refusal": {
            "type": "string",
            "description": "Refusal message from assistant"
          },
          "annotations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotation"
            },
            "description": "Message annotations"
          },
          "thought": {
            "type": "string",
            "description": "Assistant's internal thought process"
          }
        }
      },
      "MessageRole": {
        "type": "string",
        "enum": [
          "user",
          "assistant",
          "system",
          "tool"
        ],
        "description": "Role of the message sender",
        "example": "user"
      },
      "ContentBlock": {
        "type": "object",
        "required": [
          "type"
        ],
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "type": "object",
            "required": [
              "type",
              "text"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "text"
                ],
                "description": "Content type for text blocks",
                "example": "text"
              },
              "text": {
                "type": "string",
                "description": "Text content",
                "example": "What do you see in this image?"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "type",
              "image_url"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "image_url"
                ],
                "description": "Content type for image blocks",
                "example": "image_url"
              },
              "image_url": {
                "$ref": "#/components/schemas/ImageURLStruct",
                "description": "Image data"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "type",
              "input_audio"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "input_audio"
                ],
                "description": "Content type for audio blocks",
                "example": "input_audio"
              },
              "input_audio": {
                "$ref": "#/components/schemas/InputAudioStruct",
                "description": "Audio data"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ImageURLStruct": {
        "type": "object",
        "required": [
          "url"
        ],
        "properties": {
          "url": {
            "type": "string",
            "description": "Image URL or data URI",
            "example": "https://example.com/image.jpg"
          },
          "detail": {
            "type": "string",
            "enum": [
              "low",
              "high",
              "auto"
            ],
            "description": "Image detail level",
            "example": "auto"
          }
        }
      },
      "InputAudioStruct": {
        "type": "object",
        "required": [
          "data"
        ],
        "properties": {
          "data": {
            "type": "string",
            "description": "Audio payload (opaque string such as a data URL or provider-accepted encoded content)"
          },
          "format": {
            "type": "string",
            "description": "Optional audio format (e.g., \"mp3\", \"wav\") or MIME type (e.g., \"audio/mp3\"); providers may auto-detect when omitted"
          }
        }
      },
      "ModelParameters": {
        "type": "object",
        "properties": {
          "temperature": {
            "type": "number",
            "minimum": 0.0,
            "maximum": 2.0,
            "description": "Controls randomness in the output",
            "example": 0.7
          },
          "top_p": {
            "type": "number",
            "minimum": 0.0,
            "maximum": 1.0,
            "description": "Nucleus sampling parameter",
            "example": 0.9
          },
          "top_k": {
            "type": "integer",
            "minimum": 1,
            "description": "Top-k sampling parameter",
            "example": 40
          },
          "max_tokens": {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum number of tokens to generate",
            "example": 1000
          },
          "stop_sequences": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Sequences that stop generation",
            "example": [
              "\n\n",
              "END"
            ]
          },
          "presence_penalty": {
            "type": "number",
            "minimum": -2.0,
            "maximum": 2.0,
            "description": "Penalizes repeated tokens",
            "example": 0.0
          },
          "frequency_penalty": {
            "type": "number",
            "minimum": -2.0,
            "maximum": 2.0,
            "description": "Penalizes frequent tokens",
            "example": 0.0
          },
          "tools": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Tool"
            },
            "description": "Available tools for the model"
          },
          "tool_choice": {
            "$ref": "#/components/schemas/ToolChoice"
          },
          "parallel_tool_calls": {
            "type": "boolean",
            "description": "Enable parallel tool execution",
            "example": true
          }
        }
      },
      "Tool": {
        "type": "object",
        "required": [
          "type",
          "function"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique tool identifier"
          },
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "Tool type",
            "example": "function"
          },
          "function": {
            "$ref": "#/components/schemas/Function"
          }
        }
      },
      "Function": {
        "type": "object",
        "required": [
          "name",
          "description",
          "parameters"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Function name",
            "example": "get_weather"
          },
          "description": {
            "type": "string",
            "description": "Function description",
            "example": "Get current weather for a location"
          },
          "parameters": {
            "$ref": "#/components/schemas/FunctionParameters"
          }
        }
      },
      "FunctionParameters": {
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Parameter type",
            "example": "object"
          },
          "description": {
            "type": "string",
            "description": "Parameter description"
          },
          "properties": {
            "type": "object",
            "additionalProperties": true,
            "description": "Parameter properties (JSON Schema)"
          },
          "required": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Required parameter names"
          },
          "enum": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Enum values for parameters"
          }
        }
      },
      "ToolChoice": {
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "none",
              "auto",
              "any",
              "function",
              "required"
            ],
            "description": "How tools should be chosen",
            "example": "auto"
          },
          "function": {
            "$ref": "#/components/schemas/ToolChoiceFunction"
          }
        }
      },
      "ToolChoiceFunction": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the function to call",
            "example": "get_weather"
          }
        }
      },
      "ToolCall": {
        "type": "object",
        "required": [
          "function"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique tool call identifier",
            "example": "tool_123"
          },
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "Tool call type",
            "example": "function"
          },
          "function": {
            "$ref": "#/components/schemas/FunctionCall"
          }
        }
      },
      "FunctionCall": {
        "type": "object",
        "required": [
          "name",
          "arguments"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Function name",
            "example": "get_weather"
          },
          "arguments": {
            "type": "string",
            "description": "JSON string of function arguments",
            "example": "{\"location\": \"San Francisco, CA\"}"
          }
        }
      },
      "Annotation": {
        "type": "object",
        "required": [
          "type",
          "url_citation"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Annotation type"
          },
          "url_citation": {
            "$ref": "#/components/schemas/Citation"
          }
        }
      },
      "Citation": {
        "type": "object",
        "required": [
          "start_index",
          "end_index",
          "title"
        ],
        "properties": {
          "start_index": {
            "type": "integer",
            "description": "Start index in the text"
          },
          "end_index": {
            "type": "integer",
            "description": "End index in the text"
          },
          "title": {
            "type": "string",
            "description": "Citation title"
          },
          "url": {
            "type": "string",
            "description": "Citation URL"
          },
          "sources": {
            "description": "Citation sources"
          },
          "type": {
            "type": "string",
            "description": "Citation type"
          }
        }
      },
      "BifrostResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique response identifier",
            "example": "chatcmpl-123"
          },
          "object": {
            "type": "string",
            "enum": [
              "text.completion",
              "chat.completion",
              "embedding",
              "speech",
              "transcribe",
              "responses.completion"
            ],
            "description": "Response type",
            "example": "chat.completion"
          },
          "choices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BifrostChatResponseChoice"
            },
            "description": "Array of completion choices for chat and text completions. Not present for `responses` type."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BifrostEmbedding"
            },
            "description": "Array of embedding objects"
          },
          "speech": {
            "$ref": "#/components/schemas/BifrostSpeech"
          },
          "transcribe": {
            "$ref": "#/components/schemas/BifrostTranscribe"
          },
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponsesMessage"
            },
            "description": "Array of messages for `responses` type."
          },
          "conversation_id": {
            "type": "string",
            "description": "The conversation ID."
          },
          "finish_reason": {
            "type": "string",
            "description": "The reason the model stopped generating tokens."
          },
          "stop_reason": {
            "type": "string",
            "description": "The reason the model stopped generating tokens."
          },
          "stop_sequence": {
            "type": "string",
            "description": "The stop sequence that was generated."
          },
          "prompt_cache": {
            "$ref": "#/components/schemas/ResponsesPromptCache"
          },
          "model": {
            "type": "string",
            "description": "Model used for generation",
            "example": "gpt-4o"
          },
          "created": {
            "type": "integer",
            "description": "Unix timestamp of creation",
            "example": 1677652288
          },
          "service_tier": {
            "type": "string",
            "description": "Service tier used"
          },
          "system_fingerprint": {
            "type": "string",
            "description": "System fingerprint"
          },
          "usage": {
            "$ref": "#/components/schemas/LLMUsage"
          },
          "extra_fields": {
            "$ref": "#/components/schemas/BifrostResponseExtraFields"
          }
        }
      },
      "BifrostChatResponseChoice": {
        "type": "object",
        "required": [
          "index",
          "message"
        ],
        "properties": {
          "index": {
            "type": "integer",
            "description": "Choice index",
            "example": 0
          },
          "message": {
            "$ref": "#/components/schemas/ChatMessage"
          },
          "finish_reason": {
            "type": "string",
            "enum": [
              "stop",
              "length",
              "tool_calls",
              "content_filter",
              "function_call"
            ],
            "description": "Reason completion stopped",
            "example": "stop"
          },
          "stop": {
            "type": "string",
            "description": "Stop sequence that ended generation"
          },
          "log_probs": {
            "$ref": "#/components/schemas/LogProbs"
          }
        }
      },
      "BifrostEmbeddingResponse": {
        "oneOf": [
          {
            "type": "array",
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "type": "array",
            "items": {
              "type": "integer"
            }
          },
          {
            "type": "string"
          }
        ]
      },
      "BifrostEmbedding": {
        "type": "object",
        "properties": {
          "index": {
            "type": "integer"
          },
          "object": {
            "type": "string"
          },
          "embedding": {
            "$ref": "#/components/schemas/BifrostEmbeddingResponse"
          }
        }
      },
      "AudioLLMUsage": {
        "type": "object",
        "properties": {
          "characters": {
            "type": "integer"
          }
        }
      },
      "BifrostSpeech": {
        "type": "object",
        "properties": {
          "usage": {
            "$ref": "#/components/schemas/AudioLLMUsage"
          },
          "audio": {
            "type": "string",
            "format": "byte",
            "description": "The audio data as a base64-encoded string."
          }
        }
      },
      "TranscriptionLogProb": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string"
          },
          "log_prob": {
            "type": "number"
          }
        }
      },
      "TranscriptionUsage": {
        "type": "object",
        "properties": {
          "prompt_tokens": {
            "type": "integer"
          },
          "completion_tokens": {
            "type": "integer"
          },
          "total_tokens": {
            "type": "integer"
          }
        }
      },
      "BifrostTranscribe": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string"
          },
          "logprobs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TranscriptionLogProb"
            }
          },
          "usage": {
            "$ref": "#/components/schemas/TranscriptionUsage"
          }
        }
      },
      "BifrostResponseExtraFields": {
        "type": "object",
        "properties": {
          "provider": {
            "$ref": "#/components/schemas/ModelProvider"
          },
          "request_type": {
            "$ref": "#/components/schemas/RequestType"
          },
          "model_requested": {
            "type": "string",
            "description": "Model requested"
          },
          "model_params": {
            "$ref": "#/components/schemas/ModelParameters"
          },
          "latency": {
            "type": "number",
            "description": "Request latency in seconds",
            "example": 1.234
          },
          "billed_usage": {
            "$ref": "#/components/schemas/BilledLLMUsage"
          },
          "raw_response": {
            "type": "object",
            "description": "Raw provider response"
          }
        }
      },
      "BilledLLMUsage": {
        "type": "object",
        "properties": {
          "prompt_tokens": {
            "type": "number",
            "description": "Billed prompt tokens"
          },
          "completion_tokens": {
            "type": "number",
            "description": "Billed completion tokens"
          },
          "search_units": {
            "type": "number",
            "description": "Billed search units"
          },
          "classifications": {
            "type": "number",
            "description": "Billed classifications"
          }
        }
      },
      "LogProbs": {
        "type": "object",
        "properties": {
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentLogProb"
            },
            "description": "Log probabilities for content"
          },
          "refusal": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogProb"
            },
            "description": "Log probabilities for refusal"
          }
        }
      },
      "ContentLogProb": {
        "type": "object",
        "required": [
          "logprob",
          "token"
        ],
        "properties": {
          "bytes": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Byte representation"
          },
          "logprob": {
            "type": "number",
            "description": "Log probability",
            "example": -0.123
          },
          "token": {
            "type": "string",
            "description": "Token",
            "example": "hello"
          },
          "top_logprobs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogProb"
            },
            "description": "Top log probabilities"
          }
        }
      },
      "LogProb": {
        "type": "object",
        "required": [
          "logprob",
          "token"
        ],
        "properties": {
          "bytes": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Byte representation"
          },
          "logprob": {
            "type": "number",
            "description": "Log probability",
            "example": -0.456
          },
          "token": {
            "type": "string",
            "description": "Token",
            "example": "world"
          }
        }
      },
      "BifrostError": {
        "type": "object",
        "required": [
          "is_bifrost_error",
          "error"
        ],
        "properties": {
          "event_id": {
            "type": "string",
            "description": "Unique error event ID",
            "example": "evt_123"
          },
          "type": {
            "type": "string",
            "description": "Error type",
            "example": "invalid_request_error"
          },
          "is_bifrost_error": {
            "type": "boolean",
            "description": "Whether error originated from Bifrost",
            "example": true
          },
          "status_code": {
            "type": "integer",
            "description": "HTTP status code",
            "example": 400
          },
          "error": {
            "$ref": "#/components/schemas/ErrorField"
          }
        }
      },
      "ErrorField": {
        "type": "object",
        "required": [
          "message"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Error type",
            "example": "invalid_request_error"
          },
          "code": {
            "type": "string",
            "description": "Error code",
            "example": "missing_required_parameter"
          },
          "message": {
            "type": "string",
            "description": "Human-readable error message",
            "example": "Provider is required"
          },
          "param": {
            "description": "Parameter that caused the error",
            "example": "provider"
          },
          "event_id": {
            "type": "string",
            "description": "Error event ID",
            "example": "evt_123"
          }
        }
      },
      "MCPClient": {
        "type": "object",
        "required": [
          "name",
          "config",
          "tools",
          "state"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique name for this MCP client",
            "example": "filesystem"
          },
          "config": {
            "$ref": "#/components/schemas/MCPClientConfig"
          },
          "tools": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Available tools from this client",
            "example": [
              "read_file",
              "list_directory",
              "write_file"
            ]
          },
          "state": {
            "$ref": "#/components/schemas/MCPConnectionState"
          }
        }
      },
      "MCPClientConfig": {
        "type": "object",
        "required": [
          "name",
          "connection_type"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Client name",
            "example": "filesystem"
          },
          "connection_type": {
            "$ref": "#/components/schemas/MCPConnectionType"
          },
          "connection_string": {
            "type": "string",
            "description": "HTTP or SSE URL (required for HTTP or SSE connections)",
            "example": "https://api.example.com/mcp"
          },
          "stdio_config": {
            "$ref": "#/components/schemas/MCPStdioConfig"
          },
          "tools_to_skip": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tools to exclude from this client",
            "example": [
              "delete_file",
              "write_file"
            ]
          },
          "tools_to_execute": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tools to include from this client (if specified, only these are used)",
            "example": [
              "read_file",
              "list_directory"
            ]
          }
        }
      },
      "MCPConnectionType": {
        "type": "string",
        "enum": [
          "http",
          "stdio",
          "sse"
        ],
        "description": "Communication protocol for MCP connections",
        "example": "stdio"
      },
      "MCPStdioConfig": {
        "type": "object",
        "required": [
          "command",
          "args"
        ],
        "properties": {
          "command": {
            "type": "string",
            "description": "Executable command to run",
            "example": "npx"
          },
          "args": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Command line arguments",
            "example": [
              "-y",
              "@modelcontextprotocol/server-filesystem"
            ]
          },
          "envs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Environment variables required",
            "example": [
              "HOME",
              "USER"
            ]
          }
        }
      },
      "MCPConnectionState": {
        "type": "string",
        "enum": [
          "connected",
          "disconnected",
          "error"
        ],
        "description": "Connection state of MCP client",
        "example": "connected"
      },
      "MCPClientToolsEdit": {
        "type": "object",
        "properties": {
          "tools_to_execute": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tools to allow from this client (whitelist)",
            "example": [
              "read_file",
              "list_directory"
            ]
          },
          "tools_to_skip": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tools to block from this client (blacklist)",
            "example": [
              "delete_file",
              "write_file"
            ]
          }
        }
      },
      "SuccessResponse": {
        "type": "object",
        "required": [
          "status",
          "message"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "success"
            ],
            "description": "Operation status",
            "example": "success"
          },
          "message": {
            "type": "string",
            "description": "Success message",
            "example": "Operation completed successfully"
          }
        }
      },
      "Key": {
        "type": "object",
        "required": [
          "value"
        ],
        "properties": {
          "value": {
            "type": "string",
            "description": "API key value or environment variable reference",
            "example": "env.OPENAI_API_KEY"
          },
          "weight": {
            "type": "number",
            "description": "Weight for load balancing",
            "example": 1.0
          },
          "models": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Models this key can access",
            "example": [
              "gpt-4o",
              "gpt-4o-mini"
            ]
          },
          "azure_key_config": {
            "type": "object",
            "properties": {
              "endpoint": {
                "type": "string",
                "description": "Azure endpoint",
                "example": "https://your-resource.openai.azure.com"
              },
              "deployments": {
                "type": "object",
                "description": "Azure deployments",
                "example": {
                  "gpt-4o": "gpt-4o-deployment"
                }
              },
              "api_version": {
                "type": "string",
                "description": "Azure API version",
                "example": "2024-02-15-preview"
              }
            },
            "description": "Azure key configuration"
          },
          "vertex_key_config": {
            "type": "object",
            "properties": {
              "project_id": {
                "type": "string",
                "description": "Vertex project ID",
                "example": "your-project-id"
              },
              "region": {
                "type": "string",
                "description": "Vertex region",
                "example": "us-central1"
              },
              "auth_credentials": {
                "type": "string",
                "description": "Vertex auth credentials",
                "example": "env.VERTEX_AUTH_CREDENTIALS"
              }
            },
            "description": "Vertex key configuration"
          },
          "bedrock_key_config": {
            "type": "object",
            "properties": {
              "access_key": {
                "type": "string",
                "description": "Bedrock access key",
                "example": "env.AWS_ACCESS_KEY_ID"
              },
              "secret_key": {
                "type": "string",
                "description": "Bedrock secret key",
                "example": "env.AWS_SECRET_ACCESS_KEY"
              },
              "session_token": {
                "type": "string",
                "description": "Bedrock session token",
                "example": "env.AWS_SESSION_TOKEN"
              },
              "region": {
                "type": "string",
                "description": "Bedrock region",
                "example": "us-east-1"
              },
              "arn": {
                "type": "string",
                "description": "Bedrock ARN",
                "example": "arn:aws:iam::123456789012:role/BedrockRole"
              },
              "deployments": {
                "type": "object",
                "description": "Bedrock deployments",
                "example": {
                  "gpt-4o": "gpt-4o-deployment"
                }
              }
            }
          }
        }
      },
      "NetworkConfig": {
        "type": "object",
        "properties": {
          "timeout": {
            "type": "integer",
            "description": "Request timeout in seconds",
            "example": 30
          },
          "max_retries": {
            "type": "integer",
            "description": "Maximum number of retries",
            "example": 3
          }
        }
      },
      "ConcurrencyAndBufferSize": {
        "type": "object",
        "properties": {
          "concurrency": {
            "type": "integer",
            "description": "Maximum concurrent requests",
            "example": 10
          },
          "buffer_size": {
            "type": "integer",
            "description": "Request buffer size",
            "example": 100
          }
        }
      },
      "ProxyConfig": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "Proxy URL",
            "example": "http://proxy.example.com:8080"
          },
          "username": {
            "type": "string",
            "description": "Proxy username"
          },
          "password": {
            "type": "string",
            "description": "Proxy password"
          }
        }
      },
      "CustomProviderConfig": {
        "type": "object",
        "properties": {
          "base_url": {
            "type": "string",
            "description": "Custom base URL for the provider"
          },
          "headers": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional headers to send with requests"
          },
          "query_params": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional query parameters to send with requests"
          }
        }
      },
      "ClientConfig": {
        "type": "object",
        "properties": {
          "initial_pool_size": {
            "type": "integer",
            "description": "Initial pool size for sync pools",
            "example": 100
          },
          "drop_excess_requests": {
            "type": "boolean",
            "description": "Whether to drop requests when queue is full",
            "example": false
          },
          "enable_logging": {
            "type": "boolean",
            "description": "Whether logging is enabled",
            "example": true
          },
          "prometheus_labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Prometheus metric labels",
            "example": [
              "environment",
              "service"
            ]
          }
        }
      },
      "LogSearchResponse": {
        "type": "object",
        "required": [
          "logs",
          "total",
          "limit",
          "offset"
        ],
        "properties": {
          "logs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogEntry"
            },
            "description": "An array of log entries that match the search criteria."
          },
          "total": {
            "type": "integer",
            "description": "Total number of matching logs",
            "example": 156
          },
          "limit": {
            "type": "integer",
            "description": "Number of logs per page",
            "example": 50
          },
          "offset": {
            "type": "integer",
            "description": "Number of logs skipped",
            "example": 0
          },
          "stats": {
            "$ref": "#/components/schemas/SearchStats"
          }
        }
      },
      "LogEntry": {
        "type": "object",
        "required": [
          "id",
          "timestamp",
          "level",
          "message"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique log entry ID",
            "example": "log_123"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Log entry timestamp",
            "example": "2023-12-01T10:30:00Z"
          },
          "level": {
            "type": "string",
            "enum": [
              "debug",
              "info",
              "warn",
              "error"
            ],
            "description": "Log level",
            "example": "info"
          },
          "message": {
            "type": "string",
            "description": "Log message",
            "example": "Request completed successfully"
          },
          "provider": {
            "$ref": "#/components/schemas/ModelProvider"
          },
          "model": {
            "type": "string",
            "description": "Model name used",
            "example": "gpt-4o"
          },
          "status": {
            "type": "string",
            "enum": [
              "success",
              "error"
            ],
            "description": "Request status",
            "example": "success"
          },
          "latency": {
            "type": "number",
            "description": "Request latency in seconds",
            "example": 1.234
          },
          "tokens": {
            "type": "integer",
            "description": "Total tokens used",
            "example": 87
          },
          "cost": {
            "type": "number",
            "description": "Request cost in dollars",
            "example": 0.002
          },
          "object": {
            "type": "string",
            "enum": [
              "chat.completion",
              "text.completion"
            ],
            "description": "Request object type",
            "example": "chat.completion"
          }
        }
      },
      "DroppedRequestsResponse": {
        "type": "object",
        "required": [
          "total_dropped",
          "recent_drops"
        ],
        "properties": {
          "total_dropped": {
            "type": "integer",
            "description": "Total number of dropped requests",
            "example": 5
          },
          "recent_drops": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DroppedRequest"
            },
            "description": "Recent dropped requests"
          }
        }
      },
      "DroppedRequest": {
        "type": "object",
        "required": [
          "timestamp",
          "reason"
        ],
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the request was dropped",
            "example": "2023-12-01T10:30:00Z"
          },
          "reason": {
            "type": "string",
            "description": "Reason for dropping the request",
            "example": "Queue overflow"
          },
          "provider": {
            "$ref": "#/components/schemas/ModelProvider"
          },
          "model": {
            "type": "string",
            "description": "Model name requested",
            "example": "gpt-4o"
          }
        }
      },
      "OpenAISpeechRequest": {
        "type": "object",
        "required": [
          "model",
          "input",
          "voice"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "TTS model to use",
            "enum": [
              "tts-1",
              "tts-1-hd"
            ],
            "example": "tts-1"
          },
          "input": {
            "type": "string",
            "description": "Text to generate audio for (max 4096 characters)",
            "example": "The quick brown fox jumped over the lazy dog.",
            "maxLength": 4096
          },
          "voice": {
            "type": "string",
            "description": "Voice to use when generating the audio",
            "enum": [
              "alloy",
              "echo",
              "fable",
              "onyx",
              "nova",
              "shimmer"
            ],
            "example": "alloy"
          },
          "response_format": {
            "type": "string",
            "description": "Format to audio in",
            "enum": [
              "mp3",
              "opus",
              "aac",
              "flac",
              "wav",
              "pcm"
            ],
            "default": "mp3",
            "example": "mp3"
          },
          "speed": {
            "type": "number",
            "description": "Speed of the generated audio (0.25 to 4.0)",
            "minimum": 0.25,
            "maximum": 4.0,
            "default": 1.0,
            "example": 1.0
          },
          "instructions": {
            "type": "string",
            "description": "Additional instructions for voice synthesis",
            "example": "Speak slowly and clearly"
          },
          "stream_format": {
            "type": "string",
            "description": "Enable streaming with Server-Sent Events",
            "enum": [
              "sse"
            ],
            "example": "sse"
          }
        }
      },
      "OpenAITranscriptionRequest": {
        "type": "object",
        "required": [
          "model",
          "file"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "ID of the model to use",
            "enum": [
              "whisper-1"
            ],
            "example": "whisper-1"
          },
          "file": {
            "type": "string",
            "format": "binary",
            "description": "Audio file object to transcribe (mp3, mp4, mpeg, mpga, m4a, wav, webm, max 25MB)"
          },
          "language": {
            "type": "string",
            "description": "Language of the input audio (ISO-639-1 format)",
            "example": "en"
          },
          "prompt": {
            "type": "string",
            "description": "Optional text to guide the model's style or continue a previous audio segment",
            "example": "ZyntriQix, Digique Plus, CynapseFive, VortiQore V8, EchoNix Pro, CyberLeap"
          },
          "response_format": {
            "type": "string",
            "description": "Format of the transcript output",
            "enum": [
              "json",
              "text",
              "srt",
              "verbose_json",
              "vtt"
            ],
            "default": "json",
            "example": "json"
          },
          "temperature": {
            "type": "number",
            "description": "Sampling temperature (0 to 1)",
            "minimum": 0,
            "maximum": 1,
            "default": 0,
            "example": 0
          },
          "include": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "segments"
              ]
            },
            "description": "Additional data to include in the response"
          },
          "timestamp_granularities": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "word",
                "segment"
              ]
            },
            "description": "Timestamp granularities to populate for this transcription",
            "default": [
              "segment"
            ]
          },
          "stream": {
            "type": "boolean",
            "description": "Enable streaming transcription",
            "default": false,
            "example": false
          }
        }
      },
      "OpenAITranscriptionResponse": {
        "type": "object",
        "required": [
          "text"
        ],
        "properties": {
          "text": {
            "type": "string",
            "description": "The transcribed text",
            "example": "Imagine the wildest idea that you've ever had, and you're curious about how it might scale to something that's a 100, a 1,000 times bigger."
          },
          "task": {
            "type": "string",
            "description": "Task that was performed",
            "example": "transcribe"
          },
          "language": {
            "type": "string",
            "description": "Detected language of the input audio",
            "example": "english"
          },
          "duration": {
            "type": "number",
            "description": "Duration of the input audio in seconds",
            "example": 8.470000267028809
          },
          "segments": {
            "type": "array",
            "description": "Segments of the transcribed text and their corresponding details",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "integer",
                  "description": "Unique identifier of the segment"
                },
                "seek": {
                  "type": "integer",
                  "description": "Seek offset of the segment"
                },
                "start": {
                  "type": "number",
                  "description": "Start time of the segment in seconds"
                },
                "end": {
                  "type": "number",
                  "description": "End time of the segment in seconds"
                },
                "text": {
                  "type": "string",
                  "description": "Text content of the segment"
                },
                "tokens": {
                  "type": "array",
                  "items": {
                    "type": "integer"
                  },
                  "description": "Array of token IDs for the text content"
                },
                "temperature": {
                  "type": "number",
                  "description": "Temperature parameter used for generating the segment"
                },
                "avg_logprob": {
                  "type": "number",
                  "description": "Average logprob of the segment"
                },
                "compression_ratio": {
                  "type": "number",
                  "description": "Compression ratio of the segment"
                },
                "no_speech_prob": {
                  "type": "number",
                  "description": "Probability of no speech in the segment"
                }
              }
            }
          },
          "words": {
            "type": "array",
            "description": "Individual words and their corresponding timestamps",
            "items": {
              "type": "object",
              "properties": {
                "word": {
                  "type": "string",
                  "description": "The text content of the word"
                },
                "start": {
                  "type": "number",
                  "description": "Start time of the word in seconds"
                },
                "end": {
                  "type": "number",
                  "description": "End time of the word in seconds"
                }
              }
            }
          }
        }
      },
      "SearchStats": {
        "type": "object",
        "properties": {
          "total_requests": {
            "type": "integer",
            "description": "Total number of requests"
          },
          "success_rate": {
            "type": "number",
            "description": "Percentage of successful requests"
          },
          "average_latency": {
            "type": "number",
            "description": "Average latency in milliseconds"
          },
          "total_tokens": {
            "type": "integer",
            "description": "Total tokens used"
          },
          "total_cost": {
            "type": "number",
            "description": "Total cost in dollars"
          }
        }
      },
      "EmbeddingRequest": {
        "type": "object",
        "required": [
          "model",
          "input"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model identifier in 'provider/model' format"
          },
          "input": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "array",
                "items": {
                  "type": "integer"
                }
              },
              {
                "type": "array",
                "items": {
                  "type": "array",
                  "items": {
                    "type": "integer"
                  }
                }
              }
            ],
            "description": "Input text or tokens to embed"
          },
          "encoding_format": {
            "type": "string",
            "enum": [
              "float",
              "base64"
            ],
            "description": "The format to return the embeddings in."
          },
          "dimensions": {
            "type": "integer",
            "description": "The number of dimensions the resulting output embeddings should have."
          }
        }
      },
      "SpeechVoiceInput": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "voice": {
                  "type": "string"
                },
                "weight": {
                  "type": "number"
                }
              }
            }
          }
        ]
      },
      "SpeechRequest": {
        "type": "object",
        "required": [
          "model",
          "input",
          "voice"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model to use for speech synthesis in 'provider/model' format"
          },
          "input": {
            "type": "string",
            "description": "Text to convert to speech"
          },
          "voice": {
            "$ref": "#/components/schemas/SpeechVoiceInput"
          },
          "instructions": {
            "type": "string",
            "description": "Additional instructions for voice synthesis"
          },
          "response_format": {
            "type": "string",
            "description": "Audio format for the response"
          },
          "speed": {
            "type": "number",
            "description": "Speed of the generated audio"
          }
        }
      },
      "TranscriptionRequest": {
        "type": "object",
        "required": [
          "model",
          "file"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model to use for transcription in 'provider/model' format"
          },
          "file": {
            "type": "string",
            "format": "binary",
            "description": "Audio file to transcribe"
          },
          "language": {
            "type": "string",
            "description": "Language of the input audio"
          },
          "prompt": {
            "type": "string",
            "description": "Optional text to guide the model's style or continue a previous audio segment"
          },
          "response_format": {
            "type": "string",
            "description": "Format of the transcript output"
          },
          "file_format": {
            "type": "string",
            "description": "The format of the audio file"
          }
        }
      },
      "ResponsesMessage": {
        "type": "object",
        "required": [
          "role",
          "content"
        ],
        "properties": {
          "role": {
            "$ref": "#/components/schemas/MessageRole"
          },
          "content": {
            "$ref": "#/components/schemas/ResponsesMessageContent"
          }
        }
      },
      "ResponsesMessageContent": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponsesContentBlock"
            }
          }
        ]
      },
      "ResponsesContentBlock": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ResponsesTextBlock"
          },
          {
            "$ref": "#/components/schemas/ResponsesToolCallBlock"
          },
          {
            "$ref": "#/components/schemas/ResponsesToolOutputBlock"
          },
          {
            "$ref": "#/components/schemas/ResponsesImageBlock"
          },
          {
            "$ref": "#/components/schemas/ResponsesAudioBlock"
          },
          {
            "$ref": "#/components/schemas/ResponsesVideoBlock"
          }
        ]
      },
      "ResponsesTextBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "text"
            ]
          },
          "text": {
            "type": "string"
          }
        }
      },
      "ResponsesToolCallBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "tool_code",
              "tool_file_search",
              "tool_web_search",
              "tool_function"
            ]
          },
          "tool_code": {
            "$ref": "#/components/schemas/ResponsesToolCode"
          },
          "tool_file_search": {
            "$ref": "#/components/schemas/ResponsesToolFileSearch"
          },
          "tool_web_search": {
            "$ref": "#/components/schemas/ResponsesToolWebSearch"
          },
          "tool_function": {
            "$ref": "#/components/schemas/ResponsesToolFunction"
          }
        }
      },
      "ResponsesToolCode": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string"
          },
          "language": {
            "type": "string"
          }
        }
      },
      "ResponsesToolFileSearch": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string"
          },
          "filter": {
            "$ref": "#/components/schemas/ResponsesToolFileSearchFilter"
          }
        }
      },
      "ResponsesToolFileSearchFilter": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "ResponsesToolWebSearch": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string"
          }
        }
      },
      "ResponsesToolFunction": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "arguments": {
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "ResponsesToolOutputBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "tool_code",
              "tool_file_search",
              "tool_web_search",
              "tool_function"
            ]
          },
          "tool_code": {
            "$ref": "#/components/schemas/ResponsesToolCodeOutput"
          },
          "tool_file_search": {
            "$ref": "#/components/schemas/ResponsesToolFileSearchOutput"
          },
          "tool_web_search": {
            "$ref": "#/components/schemas/ResponsesToolWebSearchOutput"
          },
          "tool_function": {
            "$ref": "#/components/schemas/ResponsesToolFunctionOutput"
          }
        }
      },
      "ResponsesToolCodeOutput": {
        "type": "object",
        "properties": {
          "output": {
            "type": "string"
          }
        }
      },
      "ResponsesToolFileSearchOutput": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "file": {
                  "type": "string"
                },
                "score": {
                  "type": "number"
                }
              }
            }
          }
        }
      },
      "ResponsesToolWebSearchOutput": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "url": {
                  "type": "string"
                },
                "score": {
                  "type": "number"
                }
              }
            }
          }
        }
      },
      "ResponsesFunctionToolCallOutput": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "object",
            "additionalProperties": true
          }
        ]
      },
      "ResponsesToolFunctionOutput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "output": {
            "$ref": "#/components/schemas/ResponsesFunctionToolCallOutput"
          }
        }
      },
      "ResponsesImageBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "image"
            ]
          },
          "source": {
            "$ref": "#/components/schemas/ResponsesImageSource"
          }
        }
      },
      "ResponsesImageSource": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "base64",
              "url"
            ]
          },
          "media_type": {
            "type": "string"
          },
          "data": {
            "type": "string"
          },
          "url": {
            "type": "string"
          }
        }
      },
      "ResponsesAudioBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "audio"
            ]
          },
          "source": {
            "$ref": "#/components/schemas/ResponsesAudioSource"
          }
        }
      },
      "ResponsesAudioSource": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "base64",
              "url"
            ]
          },
          "media_type": {
            "type": "string"
          },
          "data": {
            "type": "string"
          },
          "url": {
            "type": "string"
          }
        }
      },
      "ResponsesVideoBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "video"
            ]
          },
          "source": {
            "$ref": "#/components/schemas/ResponsesVideoSource"
          }
        }
      },
      "ResponsesVideoSource": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "base64",
              "url"
            ]
          },
          "media_type": {
            "type": "string"
          },
          "data": {
            "type": "string"
          },
          "url": {
            "type": "string"
          }
        }
      },
      "ResponsesPromptCache": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string"
          }
        }
      },
      "LLMUsage": {
        "type": "object",
        "properties": {
          "prompt_tokens": {
            "type": "integer",
            "description": "Tokens in the prompt",
            "example": 56
          },
          "completion_tokens": {
            "type": "integer",
            "description": "Tokens in the completion",
            "example": 31
          },
          "total_tokens": {
            "type": "integer",
            "description": "Total tokens used",
            "example": 87
          },
          "completion_tokens_details": {
            "$ref": "#/components/schemas/CompletionTokensDetails"
          }
        }
      },
      "CompletionTokensDetails": {
        "type": "object",
        "properties": {
          "reasoning_tokens": {
            "type": "integer",
            "description": "Tokens used for reasoning"
          },
          "audio_tokens": {
            "type": "integer",
            "description": "Tokens used for audio"
          },
          "accepted_prediction_tokens": {
            "type": "integer",
            "description": "Accepted prediction tokens"
          },
          "rejected_prediction_tokens": {
            "type": "integer",
            "description": "Rejected prediction tokens"
          }
        }
      },
      "ResponsesRequest": {
        "type": "object",
        "required": [
          "model",
          "input"
        ],
        "properties": {
          "model": {
            "type": "string",
            "description": "Model identifier in 'provider/model' format"
          },
          "input": {
            "oneOf": [
              {
                "type": "string",
                "description": "Simple text input for the response"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ResponsesMessage"
                },
                "description": "Array of ResponsesMessage objects for structured input"
              }
            ]
          },
          "fallbacks": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "stream": {
            "type": "boolean"
          },
          "background": {
            "type": "boolean"
          },
          "conversation": {
            "type": "string"
          },
          "include": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "instructions": {
            "type": "string"
          },
          "max_output_tokens": {
            "type": "integer"
          },
          "max_tool_calls": {
            "type": "integer"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true
          },
          "parallel_tool_calls": {
            "type": "boolean"
          },
          "previous_response_id": {
            "type": "string"
          },
          "prompt_cache_key": {
            "type": "string"
          },
          "reasoning": {
            "$ref": "#/components/schemas/ResponsesParametersReasoning"
          },
          "safety_identifier": {
            "type": "string"
          },
          "service_tier": {
            "type": "string"
          },
          "stream_options": {
            "$ref": "#/components/schemas/ResponsesStreamOptions"
          },
          "store": {
            "type": "boolean"
          },
          "temperature": {
            "type": "number"
          },
          "text": {
            "$ref": "#/components/schemas/ResponsesTextConfig"
          },
          "top_logprobs": {
            "type": "integer"
          },
          "top_p": {
            "type": "number"
          },
          "tool_choice": {
            "$ref": "#/components/schemas/ResponsesToolChoice"
          },
          "tools": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponsesTool"
            }
          },
          "truncation": {
            "type": "string"
          }
        }
      },
      "ResponsesParametersReasoning": {
        "type": "object",
        "properties": {
          "effort": {
            "type": "string"
          }
        }
      },
      "ResponsesStreamOptions": {
        "type": "object",
        "properties": {
          "include_usage": {
            "type": "boolean"
          }
        }
      },
      "ResponsesTextConfig": {
        "type": "object",
        "properties": {
          "max_tokens": {
            "type": "integer"
          }
        }
      },
      "ResponsesToolChoice": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "auto",
              "any",
              "none",
              "required",
              "tool"
            ]
          },
          {
            "$ref": "#/components/schemas/ResponsesTool"
          }
        ]
      },
      "ResponsesTool": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "function",
              "code_interpreter",
              "file_search",
              "web_search"
            ]
          },
          "function": {
            "$ref": "#/components/schemas/ResponsesToolFunction"
          }
        }
      },
      "BifrostStreamEvent": {
        "type": "object",
        "properties": {
          "BifrostResponse": {
            "$ref": "#/components/schemas/BifrostResponse"
          },
          "BifrostError": {
            "$ref": "#/components/schemas/BifrostError"
          }
        }
      },
      "Plugin": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "config": {
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "CreatePluginRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "config": {
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "UpdatePluginRequest": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "config": {
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "VirtualKey": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "team_id": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "is_active": {
            "type": "boolean"
          },
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Key"
            }
          },
          "budget": {
            "$ref": "#/components/schemas/Budget"
          },
          "rate_limit": {
            "$ref": "#/components/schemas/RateLimit"
          },
          "provider_configs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VirtualKeyProviderConfig"
            }
          }
        }
      },
      "VirtualKeyProviderConfig": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string"
          },
          "weight": {
            "type": "number"
          },
          "allowed_models": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Team": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/Budget"
          }
        }
      },
      "Customer": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/Budget"
          }
        }
      },
      "Budget": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "max_limit": {
            "type": "number"
          },
          "reset_duration": {
            "type": "string"
          },
          "last_reset": {
            "type": "string",
            "format": "date-time"
          },
          "current_usage": {
            "type": "number"
          }
        }
      },
      "RateLimit": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "token_max_limit": {
            "type": "integer"
          },
          "token_reset_duration": {
            "type": "string"
          },
          "request_max_limit": {
            "type": "integer"
          },
          "request_reset_duration": {
            "type": "string"
          },
          "token_last_reset": {
            "type": "string",
            "format": "date-time"
          },
          "request_last_reset": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "CreateVirtualKeyRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "allowed_models": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "provider_configs": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "provider": {
                  "type": "string"
                },
                "weight": {
                  "type": "number"
                },
                "allowed_models": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "team_id": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/CreateBudgetRequest"
          },
          "rate_limit": {
            "$ref": "#/components/schemas/CreateRateLimitRequest"
          },
          "key_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "is_active": {
            "type": "boolean"
          }
        }
      },
      "UpdateVirtualKeyRequest": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "allowed_models": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "provider_configs": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "integer"
                },
                "provider": {
                  "type": "string"
                },
                "weight": {
                  "type": "number"
                },
                "allowed_models": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "team_id": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/UpdateBudgetRequest"
          },
          "rate_limit": {
            "$ref": "#/components/schemas/UpdateRateLimitRequest"
          },
          "key_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "is_active": {
            "type": "boolean"
          }
        }
      },
      "CreateBudgetRequest": {
        "type": "object",
        "properties": {
          "max_limit": {
            "type": "number"
          },
          "reset_duration": {
            "type": "string"
          }
        }
      },
      "UpdateBudgetRequest": {
        "type": "object",
        "properties": {
          "max_limit": {
            "type": "number"
          },
          "reset_duration": {
            "type": "string"
          }
        }
      },
      "CreateRateLimitRequest": {
        "type": "object",
        "properties": {
          "token_max_limit": {
            "type": "integer"
          },
          "token_reset_duration": {
            "type": "string"
          },
          "request_max_limit": {
            "type": "integer"
          },
          "request_reset_duration": {
            "type": "string"
          }
        }
      },
      "UpdateRateLimitRequest": {
        "type": "object",
        "properties": {
          "token_max_limit": {
            "type": "integer"
          },
          "token_reset_duration": {
            "type": "string"
          },
          "request_max_limit": {
            "type": "integer"
          },
          "request_reset_duration": {
            "type": "string"
          }
        }
      },
      "CreateTeamRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/CreateBudgetRequest"
          }
        }
      },
      "UpdateTeamRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "customer_id": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/UpdateBudgetRequest"
          }
        }
      },
      "CreateCustomerRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/CreateBudgetRequest"
          }
        }
      },
      "UpdateCustomerRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "budget": {
            "$ref": "#/components/schemas/UpdateBudgetRequest"
          }
        }
      },
      "BifrostStream": {
        "type": "string",
        "description": "Server-Sent Events stream of Bifrost responses."
      },
      "ProviderResponse": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/ModelProvider"
          },
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Key"
            },
            "description": "API keys for the provider"
          },
          "network_config": {
            "$ref": "#/components/schemas/NetworkConfig"
          },
          "concurrency_and_buffer_size": {
            "$ref": "#/components/schemas/ConcurrencyAndBufferSize"
          },
          "proxy_config": {
            "$ref": "#/components/schemas/ProxyConfig"
          },
          "send_back_raw_response": {
            "type": "boolean",
            "description": "Include raw provider response in BifrostResponse"
          },
          "custom_provider_config": {
            "$ref": "#/components/schemas/CustomProviderConfig"
          }
        }
      },
      "ListProvidersResponse": {
        "type": "object",
        "properties": {
          "providers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProviderResponse"
            }
          },
          "total": {
            "type": "integer"
          }
        }
      },
      "AddProviderRequest": {
        "type": "object",
        "properties": {
          "provider": {
            "$ref": "#/components/schemas/ModelProvider"
          },
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Key"
            },
            "description": "API keys for the provider"
          },
          "network_config": {
            "$ref": "#/components/schemas/NetworkConfig"
          },
          "concurrency_and_buffer_size": {
            "$ref": "#/components/schemas/ConcurrencyAndBufferSize"
          },
          "proxy_config": {
            "$ref": "#/components/schemas/ProxyConfig"
          },
          "send_back_raw_response": {
            "type": "boolean",
            "description": "Include raw provider response in BifrostResponse"
          },
          "custom_provider_config": {
            "$ref": "#/components/schemas/CustomProviderConfig"
          }
        }
      },
      "UpdateProviderRequest": {
        "type": "object",
        "properties": {
          "keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Key"
            },
            "description": "API keys for the provider"
          },
          "network_config": {
            "$ref": "#/components/schemas/NetworkConfig"
          },
          "concurrency_and_buffer_size": {
            "$ref": "#/components/schemas/ConcurrencyAndBufferSize"
          },
          "proxy_config": {
            "$ref": "#/components/schemas/ProxyConfig"
          },
          "send_back_raw_response": {
            "type": "boolean",
            "description": "Include raw provider response in BifrostResponse"
          },
          "custom_provider_config": {
            "$ref": "#/components/schemas/CustomProviderConfig"
          }
        }
      },
      "Log": {
        "type": "object",
        "properties": {
          "ID": {
            "type": "integer"
          },
          "CreatedAt": {
            "type": "string",
            "format": "date-time"
          },
          "UpdatedAt": {
            "type": "string",
            "format": "date-time"
          },
          "DeletedAt": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "request_id": {
            "type": "string"
          },
          "provider": {
            "type": "string"
          },
          "model": {
            "type": "string"
          },
          "object": {
            "type": "string"
          },
          "status": {
            "type": "string"
          },
          "request_body": {
            "type": "string"
          },
          "response_body": {
            "type": "string"
          },
          "latency": {
            "type": "integer",
            "description": "in nanoseconds"
          },
          "is_streaming": {
            "type": "boolean"
          },
          "stream_channel": {
            "type": "string"
          },
          "prompt_tokens": {
            "type": "integer"
          },
          "completion_tokens": {
            "type": "integer"
          },
          "total_tokens": {
            "type": "integer"
          },
          "cost": {
            "type": "number"
          },
          "billed_tokens": {
            "type": "integer"
          },
          "billed_cost": {
            "type": "number"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "virtual_key": {
            "type": "string"
          },
          "key": {
            "type": "string"
          },
          "custom_id": {
            "type": "string"
          },
          "user": {
            "type": "string"
          },
          "is_fallback": {
            "type": "boolean"
          },
          "retry_count": {
            "type": "integer"
          },
          "target": {
            "type": "string"
          },
          "plugin_execution": {
            "type": "string"
          },
          "plugin_short_circuit": {
            "type": "boolean"
          },
          "semantic_cache_hit": {
            "type": "boolean"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "LogSearchResult": {
        "type": "object",
        "properties": {
          "logs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Log"
            }
          },
          "total": {
            "type": "integer",
            "format": "int64"
          }
        }
      }
    },
    "responses": {
      "BadRequest": {
        "description": "Bad Request - Invalid request format or missing required fields",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BifrostError"
            },
            "example": {
              "is_bifrost_error": true,
              "status_code": 400,
              "error": {
                "type": "invalid_request_error",
                "message": "Invalid request format"
              }
            }
          }
        }
      },
      "Unauthorized": {
        "description": "Unauthorized - Invalid or missing API key",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BifrostError"
            },
            "example": {
              "is_bifrost_error": true,
              "status_code": 401,
              "error": {
                "type": "authentication_error",
                "message": "Invalid API key provided"
              }
            }
          }
        }
      },
      "RateLimited": {
        "description": "Rate Limited - Too many requests",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BifrostError"
            },
            "example": {
              "is_bifrost_error": true,
              "status_code": 429,
              "error": {
                "type": "rate_limit_error",
                "message": "Rate limit exceeded"
              }
            }
          }
        }
      },
      "InternalServerError": {
        "description": "Internal Server Error - An unexpected error occurred",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BifrostError"
            },
            "example": {
              "is_bifrost_error": true,
              "status_code": 500,
              "error": {
                "type": "api_error",
                "message": "Internal server error occurred"
              }
            }
          }
        }
      }
    }
  },
  "tags": [
    {
      "name": "Bifrost Core",
      "description": "Core endpoints for interacting with AI models."
    },
    {
      "name": "Providers",
      "description": "Endpoints for managing provider configurations."
    },
    {
      "name": "Logging",
      "description": "Endpoints for searching and managing logs."
    },
    {
      "name": "Plugins",
      "description": "Endpoints for managing plugins."
    },
    {
      "name": "Governance",
      "description": "Endpoints for managing virtual keys, teams, and customers."
    },
    {
      "name": "Cache",
      "description": "Endpoints for managing the semantic cache."
    },
    {
      "name": "Configuration",
      "description": "Endpoints for managing server configuration."
    },
    {
      "name": "Monitoring",
      "description": "Monitoring and observability endpoint"
    },
    {
      "name": "Integration - OpenAI",
      "description": "OpenAI-compatible endpoints."
    },
    {
      "name": "Integration - Anthropic",
      "description": "Anthropic-compatible endpoints."
    },
    {
      "name": "Integration - Gemini",
      "description": "Google Gemini-compatible endpoints."
    },
    {
      "name": "Integration - LiteLLM",
      "description": "LiteLLM-compatible endpoints."
    },
    {
      "name": "Integration - LangChain",
      "description": "LangChain-compatible endpoints."
    }
  ]
}