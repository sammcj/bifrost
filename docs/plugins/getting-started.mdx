---
title: "Getting Started"
description: "Learn how to extend Bifrost's functionality by creating custom plugins that intercept and modify requests and responses."
icon: "book"
---

<Note>
Dynamic plugins are only enabled on Docker builds of the OSS version. If you are using npx, you won't be able to dynamically load the .so files. 
</Note>


## What are Bifrost Plugins?

Bifrost plugins allow you to extend the gateway's functionality by intercepting requests and responses. Plugins can modify, log, validate, or enrich data as it flows through the system, giving you powerful hooks into Bifrost's request lifecycle.

## Use Cases

Custom plugins enable you to:

- **Transform requests and responses** - Modify data before it reaches providers or after it returns
- **Add custom validation** - Enforce business rules on incoming requests
- **Implement custom caching** - Cache responses based on custom logic
- **Integrate with external systems** - Send data to logging, monitoring, or analytics platforms
- **Apply custom transformations** - Parse, filter, or enrich LLM responses

## Plugin Architecture

![architecture](../media/dynamic-plugins-architecture.png)

Bifrost leverages **Go's native plugin system** to enable dynamic extensibility. Plugins are built as **shared object files** (`.so` files) that are loaded at runtime by the Bifrost gateway.

### How Go Plugins Work

Go plugins use the `plugin` package from the standard library, which allows Go programs to dynamically load code at runtime. Here's what makes this approach powerful:

- **Native Go Integration** - Plugins are written in Go and have full access to Bifrost's type system and interfaces
- **Dynamic Loading** - Plugins can be loaded, unloaded, and reloaded without restarting Bifrost
- **Type Safety** - Go's type system ensures plugin methods match expected signatures
- **Performance** - No IPC overhead; plugins run in the same process as Bifrost

### Building Shared Objects

Plugins must be compiled as shared objects using Go's `-buildmode=plugin` flag:

```bash
go build -buildmode=plugin -o myplugin.so main.go
```

This generates a `.so` file that exports specific functions matching Bifrost's plugin interface:

- `Init(config any) error` - Initialize the plugin with configuration
- `GetName() string` - Return the plugin name
- `PreHook()` - Intercept requests before they reach providers
- `PostHook()` - Process responses after provider calls
- `TransportInterceptor()` - Modify raw HTTP headers/body (HTTP transport only)
- `Cleanup() error` - Clean up resources on shutdown

### Platform Requirements

**Important Limitations:**

- **Supported Platforms**: Linux and macOS (Darwin) only
- **No Cross-Compilation**: Plugins must be built on the target platform
- **Architecture Matching**: Plugin and Bifrost must use the same architecture (amd64, arm64)
- **Go Version Compatibility**: Plugin must be built with the same Go version as Bifrost

This means if you're running Bifrost on Linux AMD64, you must build your plugin on Linux AMD64 with the same Go version.

### Plugin Lifecycle

1. **Load** - Bifrost loads the `.so` file using Go's `plugin.Open()`
2. **Initialize** - Calls `Init()` with configuration from `config.json`
3. **Hook Execution** - Calls `PreHook()` and `PostHook()` for each request
4. **Cleanup** - Calls `Cleanup()` when Bifrost shuts down

Plugins execute in a specific order:
1. `TransportInterceptor` - Modifies raw HTTP requests (HTTP transport only)
2. `PreHook` - Executes in registration order, can short-circuit requests
3. Provider call (if not short-circuited)
4. `PostHook` - Executes in reverse order of PreHooks

## Next Steps

Ready to build your first plugin? Continue to [Writing Plugins](./writing-plugin) to learn how to create, build, and deploy custom plugins for Bifrost.

